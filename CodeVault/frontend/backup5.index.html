<!DOCTYPE html>
<html>
<head>
  <title>Stock Chart with Trendline Volume</title>
  <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
  <style>
    #popupMenu {
      position: absolute;
      display: none;
      background: white;
      border: 1px solid #ccc;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
    }
    #popupMenu div {
      padding: 8px;
      cursor: pointer;
    }
    #popupMenu div:hover {
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <h2>ðŸ“ˆ Stock Chart with Trendline Volume</h2>

  <div style="margin-bottom: 10px;">
    <input type="text" id="symbolInput" placeholder="Enter stock symbol (e.g. GE)" />
  </div>

  <div id="plot" style="height: 600px;"></div>

  <div id="popupMenu"></div>
  
<script>
  let currentSymbol = null;
  let drawnLines = []; // Each item: { id, x0, x1, y0, y1, volume }
  let selectedLineId = null;
  let relayoutGuard = false;
  let suppressSave = false; // Prevents saving during initial redraw

  document.getElementById("symbolInput").addEventListener("keydown", function(e) {
    if (e.key === "Enter") loadChart();
  });

  document.addEventListener("keydown", function(e) {
    if (e.key === "Delete" && selectedLineId !== null) {
      deleteSelectedLine();
    }
  });

  document.addEventListener('click', function(e) {
    const menu = document.getElementById('popupMenu');
    if (menu.style.display !== 'none' && !menu.contains(e.target)) {
      hidePopup();
    }
  });

  function deleteLineFromBackend(lineId) {
    fetch("/delete_line", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        symbol: currentSymbol,
        line_id: lineId
      })
    });
  }

  function deleteSelectedLine() {
    if (selectedLineId === null) return;

    drawnLines = drawnLines.filter(line => line.id !== selectedLineId);

    const updatedShapes = drawnLines.map(line => ({
      type: "line",
      x0: line.x0,
      x1: line.x1,
      y0: line.y0,
      y1: line.y1,
      line: { color: "black" },
      _id: line.id
    }));

    const updatedAnnotations = drawnLines.map(line => ({
      x: new Date((new Date(line.x0).getTime() + new Date(line.x1).getTime()) / 2),
      y: (line.y0 + line.y1) / 2,
      text: `Avg Vol: ${Math.round(line.volume).toLocaleString()}`,
      showarrow: false,
      font: { color: "blue", size: 12 }
    }));

    Plotly.relayout("plot", {
      shapes: updatedShapes,
      annotations: updatedAnnotations
    });

    deleteLineFromBackend(selectedLineId);
    selectedLineId = null;
  }

  function clearAllLines() {
    Plotly.relayout("plot", { shapes: [], annotations: [] });
    drawnLines = [];
    selectedLineId = null;
    hidePopup();

    console.log("ðŸ§¹ Clear request for symbol:", currentSymbol);

    fetch("/clear_lines", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ symbol: currentSymbol })
    });
  }

  function hidePopup() {
    document.getElementById("popupMenu").style.display = "none";
  }

  function updateShapesColors() {
    const plotDiv = document.getElementById('plot');
    const layout = plotDiv.layout;
    const updatedShapes = layout.shapes.map(shape => ({
      ...shape,
      line: {
        ...shape.line,
        color: (shape._id === selectedLineId) ? 'red' : 'black'
      }
    }));
    Plotly.relayout('plot', { shapes: updatedShapes });
  }

  function getDataCoords(e) {
    const gd = document.getElementById('plot');
    const bb = gd.getBoundingClientRect();
    const px = e.clientX - bb.left;
    const py = e.clientY - bb.top;
    const layout = gd._fullLayout;
    if (!layout) return null;
    const xInPlot = px - layout.margin.l;
    const yInPlot = py - layout.margin.t;
    const xCoord = layout.xaxis.p2c(xInPlot);
    if (!xCoord) return null;
    const xData = new Date(xCoord).getTime();
    const yData = layout.yaxis.p2c(yInPlot);
    return { x: xData, y: yData };
  }

  function distanceToSegment(p, a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    if (dx === 0 && dy === 0) {
      return Math.hypot(p.x - a.x, p.y - a.y);
    }
    let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy);
    t = Math.max(0, Math.min(1, t));
    const projX = a.x + t * dx;
    const projY = a.y + t * dy;
    return Math.hypot(p.x - projX, p.y - projY);
  }

  function loadChart() {
    const symbol = document.getElementById("symbolInput").value.trim().toUpperCase();
    if (!symbol) return;

    currentSymbol = symbol;
    drawnLines = [];
    selectedLineId = null;

    fetch(`/data/${symbol}`)
      .then(res => res.json())
      .then(data => {
        if (data.length === 0) {
          alert("No data found for symbol: " + symbol);
          return;
        }

        const trace = {
          x: data.map(row => row.Date),
          open: data.map(row => row.Open),
          high: data.map(row => row.High),
          low: data.map(row => row.Low),
          close: data.map(row => row.Close),
          type: "candlestick",
          xaxis: "x",
          yaxis: "y"
        };

        const layout = {
          title: `${symbol} Candlestick Chart`,
          dragmode: "drawline",
          shapes: [],
          annotations: [],
          xaxis: { rangeslider: { visible: false } },
          yaxis: { title: "Price" }
        };

        Plotly.newPlot("plot", [trace], layout).then(() => {
          const plotDiv = document.getElementById("plot");

          // Load saved lines
          fetch(`/lines/${symbol}`)
            .then(res => res.json())
            .then(savedLines => {
              const shapes = savedLines.map(line => ({
                type: "line",
                x0: line.x0,
                x1: line.x1,
                y0: line.y0,
                y1: line.y1,
                line: { color: "black" },
                _id: line.id
              }));

              const annotations = savedLines.map(line => ({
                x: new Date((new Date(line.x0).getTime() + new Date(line.x1).getTime()) / 2),
                y: (line.y0 + line.y1) / 2,
                text: `Avg Vol: ${Math.round(line.volume).toLocaleString()}`,
                showarrow: false,
                font: { color: "blue", size: 12 }
              }));

              drawnLines = savedLines;
              suppressSave = true;
              Plotly.relayout("plot", { shapes, annotations });
              suppressSave = false;
            });

          // Handle line edits
          plotDiv.on('plotly_relayout', function(event) {
            if (relayoutGuard || suppressSave) return;
            relayoutGuard = true;
            setTimeout(() => { relayoutGuard = false; }, 100);

            const shapes = plotDiv.layout.shapes || [];

            shapes.forEach((shape) => {
              if (shape.type !== "line") return;

              if (!shape._id) {
                shape._id = crypto.randomUUID();
              }

              const { x0, x1, y0, y1 } = shape;
              const existing = drawnLines.find(l => l.id === shape._id);

              const coordsChanged = !existing ||
                existing.x0 !== x0 || existing.x1 !== x1 ||
                existing.y0 !== y0 || existing.y1 !== y1;

              if (!coordsChanged) return;

              fetch("/volume", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  symbol: currentSymbol,
                  start_date: x0,
                  end_date: x1
                })
              })
              .then(res => res.json())
              .then(data => {
                const avgVolume = data.avg_volume;
                const midX = new Date((new Date(x0).getTime() + new Date(x1).getTime()) / 2);
                const midY = (y0 + y1) / 2;

                const annotation = {
                  x: midX,
                  y: midY,
                  text: `Avg Vol: ${Math.round(avgVolume).toLocaleString()}`,
                  showarrow: false,
                  font: { color: "blue", size: 12 }
                };

                const layout = plotDiv.layout;
                const annotations = layout.annotations || [];

                if (existing) {
                  annotations[drawnLines.indexOf(existing)] = annotation;
                  Object.assign(existing, { x0, x1, y0, y1, volume: avgVolume });
                } else {
                  annotations.push(annotation);
                  drawnLines.push({ id: shape._id, x0, x1, y0, y1, volume: avgVolume });
                }

                Plotly.relayout("plot", { annotations });

                // Save line to backend
                fetch("/save_line", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify({
                    symbol: currentSymbol,
                    line: {
                      id: shape._id,
                      x0, x1, y0, y1,
                      volume: avgVolume
                    }
                  })
                });
              });
            });
          });

          // Handle line selection via click
          plotDiv.addEventListener('click', function(e) {
            const pos = getDataCoords(e);
            if (!pos) return;

            const clicked_time = pos.x; // ms
            const clickedY = pos.y;

            // Get current ranges for normalization
            const layout = plotDiv._fullLayout;
            const x_min = new Date(layout.xaxis.range[0]).getTime();
            const x_max = new Date(layout.xaxis.range[1]).getTime();
            const y_min = layout.yaxis.range[0];
            const y_max = layout.yaxis.range[1];

            const clicked_xn = (clicked_time - x_min) / (x_max - x_min);
            const clicked_yn = (clickedY - y_min) / (y_max - y_min);

            let closestId = null;
            let minDistance = Infinity;

            const shapes = plotDiv.layout.shapes || [];

            shapes.forEach((shape) => {
              if (shape.type !== "line") return;

              const x0_time = new Date(shape.x0).getTime();
              const x1_time = new Date(shape.x1).getTime();
              const x0n = (x0_time - x_min) / (x_max - x_min);
              const x1n = (x1_time - x_min) / (x_max - x_min);
              const y0n = (shape.y0 - y_min) / (y_max - y_min);
              const y1n = (shape.y1 - y_min) / (y_max - y_min);

              const dist = distanceToSegment(
                { x: clicked_xn, y: clicked_yn },
                { x: x0n, y: y0n },
                { x: x1n, y: y1n }
              );

              if (dist < minDistance) {
                minDistance = dist;
                closestId = shape._id;
              }
            });

            const threshold = 0.05; // Increased slightly if needed, but 0.05 should be fine
            if (minDistance < threshold) {
              if (closestId === selectedLineId) {
                selectedLineId = null;
              } else {
                selectedLineId = closestId;
              }
            } else {
              selectedLineId = null;
            }

            updateShapesColors();
          });

          // Handle right-click context menu
          plotDiv.addEventListener("contextmenu", function(e) {
            e.preventDefault();

            const menu = document.getElementById("popupMenu");
            menu.innerHTML = '';

            if (selectedLineId !== null) {
              const deleteDiv = document.createElement('div');
              deleteDiv.textContent = 'ðŸ—‘ï¸ Delete Selected Line';
              deleteDiv.onclick = function() {
                deleteSelectedLine();
                hidePopup();
              };
              menu.appendChild(deleteDiv);
            }

            const clearDiv = document.createElement('div');
            clearDiv.textContent = 'ðŸ§¹ Clear All Lines';
            clearDiv.onclick = function() {
              clearAllLines();
              hidePopup();
            };
            menu.appendChild(clearDiv);

            menu.style.left = e.pageX + "px";
            menu.style.top = e.pageY + "px";
            menu.style.display = "block";
          });
        });
      });
  }
</script>
</body>
</html>